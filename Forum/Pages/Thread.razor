@page "/thread/{Id:int}"
@attribute [Authorize]
@using Microsoft.EntityFrameworkCore
@using System.IO
@* ReSharper disable once InconsistentNaming *@
@inject NavigationManager NavMan
@* ReSharper disable once InconsistentNaming *@
@inject IJSRuntime JSRuntime
@* ReSharper disable once InconsistentNaming *@
@inject Data.InfoMessage MessageService
@* ReSharper disable once InconsistentNaming *@
@inject IDbContextFactory<Model.Database> DbContext

<div class="container-left fix-left">
	<div class="main row">
		<button class="btn-norm-sec" @onclick="NavHome">
			<img width="50" height="50" src="/css/icons/Arrow_Back.png" alt="Back Arrow" />
			Go Back
		</button>
	</div>
</div>
@* NOTE: '==' and '!=' call the equality operator _which can be overridden_:
 *     public static bool operator ==(<object> a, <object> b) { } 
 * 'is' and 'is not' load the values on the stack and do a simple bit-by-bit
 * comparison, which is more efficient and cannot lie to you.
 *@
@if (_thread is not null)
{
	<div class="container-middle">
		<div class="main needs-padding">
			<p class="p-annotation-sm">
				<a href="/user/@_thread.Creator.AccountName">@_thread.Creator.AccountName</a>
				@@@_thread.Forum.Name
				@_thread.Created.ToString("t"), @_thread.Created.ToString("d")
			</p>
			<h5 class="txt-title">@_thread?.Title</h5>
			<pre class="txt-title">@_content</pre>
			@{
				var tagText = "";
				// ReSharper disable once LoopCanBeConvertedToQuery
				foreach (var t in _thread.Tags)
				{
					tagText += ' ' + t.Name;
				}
			}
			<small>Tags: @tagText</small>
		</div>
		<div class="second row">
			@* Number of Pages, 20 Comments per Page
		 * ( number_of_comments + comments_per_page - 1 ) / comments_per_page
		 *@
			<p class="p-annotation-sm txt-dark needs-space-lr">@_thread.Comments.Count Comments (@((_thread.Comments.Count + 19) / 20) Pages)</p>
			<p @onclick="CopyLink" class="p-annotation-sm txt-dark needs-space-lr clickable shiny">@_copyLabel</p>
			<p @onclick="SaveThread" class="p-annotation-sm txt-dark needs-space-lr clickable shiny">@(_saved ? "Saved!" : "Save")</p>
			@{ var dbContext = DbContext.CreateDbContext(); }
			@if (!_thread.IsDeleted &&
			     _thread.Creator == dbContext.Users.First(u => u.AccountName == _authState.User.Identity.Name))
			{
				<p @onclick="Delete" class="p-annotation-sm txt-dark needs-space-lr clickable shiny">Delete</p>
			}
			@{dbContext.Dispose();}
		</div>
		<div class="main">
			<CommentField Thread="@_thread" UpdateHandler="Update"/>
		</div>
		@foreach (var c in _thread.Comments)
		{
			if (c.Parent is not null) continue;

			<Comment CommentModel="c"/>
		}
	</div>
	<div class="container-right fix-right">
		<div class="second needs-padding">
			<img width="100" height="100" src="/css/icons/Default.jpg" alt="Forum Image" />
			<h5>@_thread.Forum.Name</h5>
			<p class="p-annotation-sm">@_thread.Forum.Members.Count Mem. / Created @_thread.Forum.Created.ToString("d")</p>
			<pre class="txt-title">@_thread.Forum.Description</pre>
			@{ var followText = _followsForum ? "Unfollow" : "Follow"; }
			<button class="btn-norm" style="width: 100%" @onclick="FollowForum">@followText</button>
		</div>
	</div>
}
else
{
	<div class="container-middle">
		<div class="main needs-padding">
			<h5 class="txt-title">Thread not found.</h5>
            <pre class="txt-title">Thread @Id doesn't seem to exist.</pre>
		</div>
	</div>
}

@code {
	[Parameter]
	public int Id { get; set; }

	[CascadingParameter]
	private Task<AuthenticationState> AuthenticationStateTask { get; set; }

	private Entity.Thread _thread;
	private AuthenticationState _authState;
	
	private string _copyLabel = "Copy Link";
	private string _content;
	private bool _saved;
	private bool _followsForum;

	protected override async Task OnInitializedAsync()
	{
		Update();
	}

	private void NavHome()
	{
		NavMan.NavigateTo("/"); // TODO: Use <a href/> instead
	}

	private async void CopyLink()
	{
		_copyLabel = "Copied!";
		var link = NavMan.Uri;
		await JSRuntime.InvokeVoidAsync("navigator.clipboard.writeText", link);
	}

	private async void SaveThread()
	{
		await using var dbContext = DbContext.CreateDbContext();
		
		var user = dbContext.Users
			.Include(u => u.SavedThreads)
			.Include(u => u.Forums)
			.First(u => u.AccountName == _authState.User.Identity.Name);

		// Get the thread from the same db context
		var thread = dbContext.Threads.First(t => t.Id == _thread.Id);
		
		if (_saved)
		{
			user.SavedThreads.Remove(thread);
			_saved = false;
		}
		else
		{
			user.SavedThreads.Add(thread);
			_saved = true;
		}

		await dbContext.SaveChangesAsync();

		StateHasChanged();
	}

	private async void FollowForum()
	{
		await using var dbContext = DbContext.CreateDbContext();
		
		var user = dbContext.Users
			.Include(u => u.Forums)
			.First(u => u.AccountName == _authState.User.Identity.Name);
		
		// Get the forum from the same db context
		var forum = dbContext.Forums.First(f => f.Id == _thread.Forum.Id);

		if (_followsForum)
		{
			user.Forums.Remove(forum);
			_followsForum = false;
		}
		else
		{
			user.Forums.Add(forum);
			_followsForum = true;
		}

		await dbContext.SaveChangesAsync();
	}

	private async void Delete()
	{
		await using var dbContext = DbContext.CreateDbContext();
		
		if (_thread.Creator != dbContext.Users.First(u => u.AccountName == _authState.User.Identity.Name)) return;
		var confirm = await JSRuntime.InvokeAsync<bool>("confirm", "Delete this thread?");

		// ReSharper disable once InvertIf
		if (confirm) 
		{ 
			_thread.IsDeleted = true;
			await dbContext.SaveChangesAsync();
			MessageService.Message = "Thread deleted.";
		}
	}

	private async void Update()
	{
		await using var dbContext = DbContext.CreateDbContext();

		_authState = await AuthenticationStateTask;

		_thread = dbContext.Threads
			.Include(t => t.Creator)
			.Include(t => t.Tags)
			.Include(t => t.Forum)
			.ThenInclude(f => f.Members)
			.Include(t => t.Comments)
			.ThenInclude(c => c.Creator)
			.FirstOrDefault(t => t.Id == Id);

		if (_thread is null) return;

		if (_thread.IsDeleted)
		{
			_content = "[ Thread deleted. ]";
		}
		else
		{
			try
			{
				var path = _thread.ContentPath;
				var streamReader = new StreamReader(path);
				_content = await streamReader.ReadToEndAsync();
				streamReader.Close();
			}
			catch (Exception)
			{
				_content = "[ An error occurred. ]";
			}
		}

		var user = dbContext.Users
			.Include(u => u.SavedThreads)
			.Include(u => u.Forums)
			.First(u => u.AccountName == _authState.User.Identity.Name);

		_saved = user.SavedThreads.Contains(_thread);
		_followsForum = user.Forums.Contains(_thread.Forum);
		
		StateHasChanged();
	}
}
